{"ast":null,"code":"// сколько звёзд может быть одновременно на экране\nvar starsCount = 800;\n// на старте массив со звёздами будет пустой\nvar stars = [];\n// класс, на основе которого будут сделаны все звёзды\nclass Star {\n  // конструктор, который вызывается при создании каждого объекта на основе этого класса\n  constructor() {\n    // у новой звезды будут случайные координаты\n    this.x = random(-width, width);\n    this.y = random(-height, height);\n    // глубина — насколько виртуально близко к экрану появится звезда\n    this.z = random(width);\n  }\n  // метод, который обновляет координаты звезды\n  update() {\n    // скорость полёта\n    var speed = 8;\n    // приближаем звезду к краю экрана, уменьшая глубину на значение скорости\n    this.z -= speed;\n    // если звезда вылетела за край экрана — делаем из неё новую звезду, для этого меняем координаты\n    if (this.z < 1) {\n      this.x = random(-width, width);\n      this.y = random(-height, height);\n      // для новой звезды вместо старой глубину появления теперь выбираем не случайным образом, а задаём прямо\n      this.z = width;\n    }\n  }\n\n  // метод, который отрисовывает звезду на экране\n  drawStar() {\n    // каждая звезда — белого цвета\n    fill(236);\n    // и без контура\n    noStroke();\n\n    // с помощью функции map() из библиотеки p5.js получаем новые координаты для отрисовки звезды \n    var sx = map(this.x / this.z, 0, 1, 0, width);\n    var sy = map(this.y / this.z, 0, 1, 0, height);\n\n    // чем ближе к краю экрана (чем меньше глубина z) — тем больше радиус \n    var r = map(this.z, 0, width, 10, 0);\n    // рисуем звезду в новых координатах и новым размером\n    ellipse(sx, sy, r, r);\n  }\n}\n\n// подготавливаем всё к запуску — то, что написано здесь выполнится автоматически сразу после загрузки\nfunction setup() {\n  // создаём холст, на котором будем рисовать\n  createCanvas(innerWidth, innerHeight);\n  // размещаем сразу все звёзды на холсте\n  for (var i = 0; i < starsCount; i++) {\n    // каждая новая звезда — объект класса Star и умеет то же самое, что и все остальные звёзды\n    stars[i] = new Star();\n  }\n}\n\n// пока мы не закроем страницу, постоянно будет выполняться функция drw() \nfunction draw() {\n  // ставим чёрный фон и указываем скорость обновления фона — чем меньше второе число, тем больший шлейф будут оставлять звёзды\n  background(16, 220);\n  // формируем центр экрана, куда «полетим» сквозь звёзды\n  translate(width / 2, height / 2);\n\n  // отрисовываем каждый раз все звёзды и меняем их положение\n  for (var i = 0; i < starsCount; i++) {\n    stars[i].drawStar();\n    stars[i].update();\n  }\n}\n\n// если поменяется размер окна браузера — сразу меняем размер холста\naddEventListener('resize', () => {\n  resizeCanvas(innerWidth, innerHeight);\n});","map":{"version":3,"names":["starsCount","stars","Star","constructor","x","random","width","y","height","z","update","speed","drawStar","fill","noStroke","sx","map","sy","r","ellipse","setup","createCanvas","innerWidth","innerHeight","i","draw","background","translate","addEventListener","resizeCanvas"],"sources":["C:/Users/Пользователь/Desktop/Portfolio/MyPortfolio/portfolio-app/src/utils/space.js"],"sourcesContent":["\t// сколько звёзд может быть одновременно на экране\n\tvar starsCount = 800;\n\t// на старте массив со звёздами будет пустой\n\tvar stars = [];\n\t// класс, на основе которого будут сделаны все звёзды\n\tclass Star{\n\t\t// конструктор, который вызывается при создании каждого объекта на основе этого класса\n\t\tconstructor(){\n\t\t\t// у новой звезды будут случайные координаты\n\t\t\tthis.x = random(-width, width);\n\t\t\tthis.y = random(-height, height);\n\t\t\t// глубина — насколько виртуально близко к экрану появится звезда\n\t\t\tthis.z = random(width);\n\t\t}\n\t\t// метод, который обновляет координаты звезды\n\t\tupdate(){\n\t\t\t// скорость полёта\n\t\t\tvar speed = 8;\n\t\t\t// приближаем звезду к краю экрана, уменьшая глубину на значение скорости\n\t\t\tthis.z -= speed;\n\t\t\t// если звезда вылетела за край экрана — делаем из неё новую звезду, для этого меняем координаты\n\t\t\tif(this.z < 1){\n\t\t\t\tthis.x = random(-width, width);\n\t\t\t\tthis.y = random(-height, height);\n\t\t\t\t// для новой звезды вместо старой глубину появления теперь выбираем не случайным образом, а задаём прямо\n\t\t\t\tthis.z = width;\n\t\t\t}\n\t\t}\n\n\t\t// метод, который отрисовывает звезду на экране\n\t\tdrawStar(){\n\t\t\t// каждая звезда — белого цвета\n\t\t\tfill(236);\n\t\t\t// и без контура\n\t\t\tnoStroke();\n\n\t\t\t// с помощью функции map() из библиотеки p5.js получаем новые координаты для отрисовки звезды \n\t\t\tvar sx = map(this.x / this.z, 0, 1, 0, width);\n\t\t\tvar sy = map(this.y / this.z, 0, 1, 0, height);\n\n\t\t\t// чем ближе к краю экрана (чем меньше глубина z) — тем больше радиус \n\t\t\tvar r = map(this.z, 0, width, 10, 0);\n\t\t\t// рисуем звезду в новых координатах и новым размером\n\t\t\tellipse(sx, sy, r, r);\n\t\t}\n\t}\n\n\t// подготавливаем всё к запуску — то, что написано здесь выполнится автоматически сразу после загрузки\n\tfunction setup(){\n\t\t// создаём холст, на котором будем рисовать\n\t\tcreateCanvas(innerWidth, innerHeight);\n\t\t// размещаем сразу все звёзды на холсте\n\t\tfor (var i = 0; i < starsCount; i++) {\n\t\t\t// каждая новая звезда — объект класса Star и умеет то же самое, что и все остальные звёзды\n\t\t\tstars[i] = new Star();\n\t\t}\n\t}\n\n// пока мы не закроем страницу, постоянно будет выполняться функция drw() \nfunction draw(){\n\t// ставим чёрный фон и указываем скорость обновления фона — чем меньше второе число, тем больший шлейф будут оставлять звёзды\n\tbackground(16, 220);\n\t// формируем центр экрана, куда «полетим» сквозь звёзды\n\ttranslate(width/2, height/2);\n\n\t// отрисовываем каждый раз все звёзды и меняем их положение\n\tfor (var i = 0; i < starsCount; i++) {\n\t\tstars[i].drawStar();\n\t\tstars[i].update();\n\t}\n}\n\n\t// если поменяется размер окна браузера — сразу меняем размер холста\n\taddEventListener('resize', () => {\n\t\tresizeCanvas(innerWidth, innerHeight);\n\t})\t"],"mappings":"AAAC;AACA,IAAIA,UAAU,GAAG,GAAG;AACpB;AACA,IAAIC,KAAK,GAAG,EAAE;AACd;AACA,MAAMC,IAAI;EACT;EACAC,WAAWA,CAAA,EAAE;IACZ;IACA,IAAI,CAACC,CAAC,GAAGC,MAAM,CAAC,CAACC,KAAK,EAAEA,KAAK,CAAC;IAC9B,IAAI,CAACC,CAAC,GAAGF,MAAM,CAAC,CAACG,MAAM,EAAEA,MAAM,CAAC;IAChC;IACA,IAAI,CAACC,CAAC,GAAGJ,MAAM,CAACC,KAAK,CAAC;EACvB;EACA;EACAI,MAAMA,CAAA,EAAE;IACP;IACA,IAAIC,KAAK,GAAG,CAAC;IACb;IACA,IAAI,CAACF,CAAC,IAAIE,KAAK;IACf;IACA,IAAG,IAAI,CAACF,CAAC,GAAG,CAAC,EAAC;MACb,IAAI,CAACL,CAAC,GAAGC,MAAM,CAAC,CAACC,KAAK,EAAEA,KAAK,CAAC;MAC9B,IAAI,CAACC,CAAC,GAAGF,MAAM,CAAC,CAACG,MAAM,EAAEA,MAAM,CAAC;MAChC;MACA,IAAI,CAACC,CAAC,GAAGH,KAAK;IACf;EACD;;EAEA;EACAM,QAAQA,CAAA,EAAE;IACT;IACAC,IAAI,CAAC,GAAG,CAAC;IACT;IACAC,QAAQ,EAAE;;IAEV;IACA,IAAIC,EAAE,GAAGC,GAAG,CAAC,IAAI,CAACZ,CAAC,GAAG,IAAI,CAACK,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEH,KAAK,CAAC;IAC7C,IAAIW,EAAE,GAAGD,GAAG,CAAC,IAAI,CAACT,CAAC,GAAG,IAAI,CAACE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAED,MAAM,CAAC;;IAE9C;IACA,IAAIU,CAAC,GAAGF,GAAG,CAAC,IAAI,CAACP,CAAC,EAAE,CAAC,EAAEH,KAAK,EAAE,EAAE,EAAE,CAAC,CAAC;IACpC;IACAa,OAAO,CAACJ,EAAE,EAAEE,EAAE,EAAEC,CAAC,EAAEA,CAAC,CAAC;EACtB;AACD;;AAEA;AACA,SAASE,KAAKA,CAAA,EAAE;EACf;EACAC,YAAY,CAACC,UAAU,EAAEC,WAAW,CAAC;EACrC;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGxB,UAAU,EAAEwB,CAAC,EAAE,EAAE;IACpC;IACAvB,KAAK,CAACuB,CAAC,CAAC,GAAG,IAAItB,IAAI,EAAE;EACtB;AACD;;AAED;AACA,SAASuB,IAAIA,CAAA,EAAE;EACd;EACAC,UAAU,CAAC,EAAE,EAAE,GAAG,CAAC;EACnB;EACAC,SAAS,CAACrB,KAAK,GAAC,CAAC,EAAEE,MAAM,GAAC,CAAC,CAAC;;EAE5B;EACA,KAAK,IAAIgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGxB,UAAU,EAAEwB,CAAC,EAAE,EAAE;IACpCvB,KAAK,CAACuB,CAAC,CAAC,CAACZ,QAAQ,EAAE;IACnBX,KAAK,CAACuB,CAAC,CAAC,CAACd,MAAM,EAAE;EAClB;AACD;;AAEC;AACAkB,gBAAgB,CAAC,QAAQ,EAAE,MAAM;EAChCC,YAAY,CAACP,UAAU,EAAEC,WAAW,CAAC;AACtC,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}